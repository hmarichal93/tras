"""
Export radial ring width measurements to .POS format for CooRecorder

CooRecorder is a widely used dendrochronology software for tree ring measurement.
The .POS format stores radial measurements along a line from the pith.

Format specification (based on CooRecorder documentation):
- Text file with extension .POS
- Each line represents one ring measurement
- Format: ring_number distance_from_pith ring_width
- Measurements in pixels or physical units (if scale is set)
- Header lines start with '#'
"""

def export_to_pos(
    filepath,
    measurements,
    pith_xy,
    direction_xy,
    image_scale=None,
    metadata=None
):
    """
    Export radial width measurements to CooRecorder .POS format
    
    Args:
        filepath: Output .POS file path
        measurements: Dict of {ring_label: {'distance_from_pith': float, 'radial_width': float}}
        pith_xy: Tuple (x, y) of pith coordinates
        direction_xy: Tuple (x, y) of direction point
        image_scale: Dict with 'value' (unit/pixel) and 'unit' if available
        metadata: Dict with 'harvested_year', 'sample_code', 'observation' if available
    
    Returns:
        True if successful, False otherwise
    """
    try:
        with open(filepath, 'w', encoding='utf-8') as f:
            # Write header
            f.write("# CooRecorder .POS format - Radial tree ring measurements\n")
            f.write("# Generated by LabelMe Tree Ring Detection Tool\n")
            f.write("#\n")
            
            # Write metadata if available
            if metadata:
                if 'sample_code' in metadata:
                    f.write(f"# Sample Code: {metadata['sample_code']}\n")
                if 'harvested_year' in metadata:
                    f.write(f"# Harvested Year: {metadata['harvested_year']}\n")
                if 'observation' in metadata:
                    f.write(f"# Observation: {metadata['observation']}\n")
            
            # Write measurement parameters
            f.write(f"# Pith Location: ({pith_xy[0]:.2f}, {pith_xy[1]:.2f})\n")
            f.write(f"# Direction Point: ({direction_xy[0]:.2f}, {direction_xy[1]:.2f})\n")
            
            # Write units
            if image_scale:
                unit = image_scale.get('unit', 'pixels')
                scale_value = image_scale.get('value', 1.0)
                f.write(f"# Units: {unit}\n")
                f.write(f"# Scale: {scale_value:.6f} {unit}/pixel\n")
            else:
                f.write("# Units: pixels\n")
            
            f.write("#\n")
            f.write("# Format: RingNumber  DistanceFromPith  RingWidth\n")
            f.write("#\n")
            
            # Sort rings by distance from pith
            sorted_rings = sorted(
                measurements.items(),
                key=lambda x: measurements[x[0]]['distance_from_pith']
            )
            
            # Write measurements
            for ring_number, (ring_label, data) in enumerate(sorted_rings, start=1):
                distance = data['distance_from_pith']
                width = data['radial_width']
                
                # Convert to physical units if scale is available
                if image_scale:
                    scale_value = image_scale['value']
                    distance_physical = distance * scale_value
                    width_physical = width * scale_value
                    f.write(f"{ring_number:4d}  {distance_physical:10.4f}  {width_physical:10.4f}\n")
                else:
                    f.write(f"{ring_number:4d}  {distance:10.2f}  {width:10.2f}\n")
            
            # Write summary
            f.write("#\n")
            f.write(f"# Total rings measured: {len(measurements)}\n")
        
        return True
    
    except Exception as e:
        print(f"Error exporting to .POS format: {e}")
        import traceback
        traceback.print_exc()
        return False

